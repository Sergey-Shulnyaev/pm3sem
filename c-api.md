[Building a Python C Extension Module](https://realpython.com/build-python-c-extension-module/)


Есть несколько способов расширить функциональность Python. Одним из них является написание вашего модуля Python на C или C++. Этот процесс может привести к повышению производительности и улучшению доступа к функциям библиотеки C и системным вызовам. В этом руководстве вы узнаете, как использовать API Python для написания модулей расширения Python C.

Вы узнаете, как:

- Вызывать функции C из Python
- Передавайте аргументы из Python в C и анализируйте их соответственно
- Вызывать исключения из кода C и создавать собственные исключения Python в C
- Определите глобальные константы в C и сделайте их доступными в Python
- Протестируйте, упакуйте и распространите ваш модуль расширения Python C

### Расширение вашей программы Python

Одна из менее известных, но невероятно мощных функций Python - это его способность вызывать функции и библиотеки, определенные в скомпилированных языках, таких как C или C++. Это позволяет вам расширить возможности вашей программы за пределы того, что могут предложить встроенные функции Python.

Есть много языков, из которых вы можете выбрать для расширения функциональности Python. Итак, почему вы должны использовать C? Вот несколько причин, почему вы можете решить создать модуль расширения Python C:

1) **Для реализации новых встроенных типов объектов**: можно написать класс Python на C, а затем создать и расширить этот класс из самого Python. Для этого может быть много причин, но чаще всего именно производительность побуждает разработчиков обращаться к C. Такая ситуация встречается редко, но хорошо знать, в какой степени Python может быть расширен.

2) **Для вызова функций библиотеки C и системных вызовов**: Многие языки программирования предоставляют интерфейсы для наиболее часто используемых системных вызовов. Тем не менее, могут быть другие менее используемые системные вызовы, которые доступны только через C. Модуль os в Python является одним из примеров.

Это не исчерпывающий список, но он дает вам представление о том, что можно сделать при расширении Python с использованием C или любого другого языка.

Чтобы писать модули Python на C, вам нужно использовать [API Python](https://docs.python.org/3.7/c-api/index.html), который определяет различные функции, макросы и переменные, которые позволяют интерпретатору Python вызывать ваш код на C. Все эти и другие инструменты собраны в [заголовочном файле Python.h](https://docs.python.org/3/c-api/intro.html#include-files).

### Написание интерфейса Python на C

В этом руководстве вы напишете небольшую оболочку для функции библиотеки C, которую затем будете вызывать из Python. Реализация оболочки самостоятельно даст вам лучшее представление о том, когда и как использовать C для расширения вашего модуля Python.

#### Понимание fputs ()

fputs() - это функция библиотеки C, которую вы будете оборачивать:

```C
int fputs(const char *, FILE *)
```

Эта функция принимает два аргумента:

const char * - это массив символов.
FILE * - указатель на файловый поток.

fputs () записывает массив символов в файл, указанный потоком файлов, и возвращает неотрицательное значение. Если операция прошла успешно, то это значение будет обозначать количество байтов, записанных в файл. Если произошла ошибка, возвращается EOF. Вы можете прочитать больше об этой функции библиотеки C и ее других вариантах в [разделе руководства](http://man7.org/linux/man-pages/man3/puts.3.html).

### Написание функции C для fputs()

Это базовая программа на C, которая использует fputs() для записи строки в файловый поток:

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    FILE *fp = fopen("write.txt", "w");
    fputs("Real Python!", fp);
    fclose(fp);
    return 1;
}
```

Этот фрагмент кода можно обобщить следующим образом:

1. Откройте файл write.txt.
2. Напишите строку «Real Python!» в файл.

В следующем разделе вы напишите обертку для этой функции C.

Может показаться немного странным увидеть полный код перед объяснением того, как он работает. Однако если вы потратите немного времени на проверку конечного продукта, вы поймете это в следующих разделах. Блок кода ниже показывает окончательную упакованную версию вашего кода C:

```C
#include <Python.h>

static PyObject *method_fputs(PyObject *self, PyObject *args) {
    char *str, *filename = NULL;
    int bytes_copied = -1;

    /* Parse arguments */
    if(!PyArg_ParseTuple(args, "ss", &str, &filename)) {
        return NULL;
    }

    FILE *fp = fopen(filename, "w");
    bytes_copied = fputs(str, fp);
    fclose(fp);

    return PyLong_FromLong(bytes_copied);
}
```
Этот фрагмент кода ссылается на три объектные структуры, которые определены в Python.h:

1. PyObject
2. PyArg_ParseTuple()
3. PyLong_FromLong()

Они используются для определения типа данных для языка Python. Вы пройдете через каждый из них сейчас.

#### PyObject

PyObject - это структура объектов, которую вы используете для определения типов объектов для Python. Все объекты Python имеют небольшое количество полей, определенных с помощью структуры PyObject. Все остальные типы объектов являются расширениями этого типа.

PyObject говорит интерпретатору Python обрабатывать указатель на объект как объект. Например, установка типа возврата вышеуказанной функции как PyObject определяет общие поля, которые требуются интерпретатору Python для распознавания его как допустимого типа Python.

Взгляните еще раз на первые несколько строк вашего C-кода:

```C
static PyObject *method_fputs(PyObject *self, PyObject *args) {
    char *str, *filename = NULL;
    int bytes_copied = -1;

    /* Snip */
```

В строке 2 вы объявляете типы аргументов, которые хотите получить из кода Python:

1. char * str - это строка, которую вы хотите записать в файловый поток.
2. char * filename - это имя файла для записи.


#### PyArg_ParseTuple ()

PyArg_ParseTuple() анализирует аргументы, которые вы получите от вашей программы Python, в локальные переменные:

```C
static PyObject *method_fputs(PyObject *self, PyObject *args) {
    char *str, *filename = NULL;
    int bytes_copied = -1;

    /* Parse arguments */
    if(!PyArg_ParseTuple(args, "ss", &str, &filename)) {
        return NULL;
    }

    /* Snip */
```

Если вы посмотрите на строку 6, то увидите, что PyArg_ParseTuple() принимает следующие аргументы:

- args имеют тип PyObject.

- «ss» - это спецификатор формата, который определяет тип данных аргументов для анализа. (Вы можете проверить [официальную документацию для полной справки](https://docs.python.org/3/c-api/arg.html).)

- &str и &filename являются указателями на локальные переменные, которым будут назначены проанализированные значения.

PyArg_ParseTuple() оценивается как ложное в случае ошибки. Если произойдет сбой, функция вернет NULL и больше не будет работать.

#### fputs()

Как вы видели ранее, `fputs()` принимает два аргумента, один из которых - объект `FILE *`. Поскольку вы не можете анализировать объект Python `textIOwrapper` с помощью Python API в C, вам придется использовать обходной путь:

```C
static PyObject *method_fputs(PyObject *self, PyObject *args) {
    char *str, *filename = NULL;
    int bytes_copied = -1;

    /* Parse arguments */
    if(!PyArg_ParseTuple(args, "ss", &str, &filename)) {
        return NULL;
    }

    FILE *fp = fopen(filename, "w");
    bytes_copied = fputs(str, fp);
    fclose(fp);

    return PyLong_FromLong(bytes_copied);
}
```

Вот разбивка того, что делает этот код:

- В строке 10 вы передаете имя файла, который  будете использовать для создания объекта `FILE *` и передачи его функции.
- В строке 11 вы вызываете `fputs()` со следующими аргументами:
-- `str` - строка, которую вы хотите записать в файл.
-- `fp` - это объект `FILE *`, который вы определили в строке 10.

Затем вы сохраняете возвращаемое значение `fputs()` в `bytes_copied`. Эта целочисленная переменная будет возвращена вызову `fputs()` в интерпретаторе Python.

#### PyLong_FromLong (bytes_copied)

`PyLong_FromLong()` возвращает PyLongObject, который представляет целочисленный объект в Python. Вы можете найти его в самом конце вашего C-кода:

```C
static PyObject *method_fputs(PyObject *self, PyObject *args) {
    char *str, *filename = NULL;
    int bytes_copied = -1;

    /* Parse arguments */
    if(!PyArg_ParseTuple(args, "ss", &str, &filename)) {
        return NULL;
    }

    FILE *fp = fopen(filename, "w");
    bytes_copied = fputs(str, fp);
    fclose(fp);

    return PyLong_FromLong(bytes_copied);
}
```

Строка 14 генерирует `PyLongObject` для `bytes_copied`, переменная, которая возвращается, когда функция вызывается в Python. Вы должны вернуть `PyObject *` из вашего модуля расширения Python C обратно в интерпретатор Python.

### Написание функции инициализации

Вы написали код, который составляет основную функциональность вашего модуля расширения Python C. Тем не менее, есть еще несколько дополнительных функций, которые необходимы для запуска вашего модуля. Вам нужно будет написать определения вашего модуля и методов, которые он содержит, например:

```C
static PyMethodDef FputsMethods[] = {
    {"fputs", method_fputs, METH_VARARGS, "Python interface for fputs C library function"},
    {NULL, NULL, 0, NULL}
};


static struct PyModuleDef fputsmodule = {
    PyModuleDef_HEAD_INIT,
    "fputs",
    "Python interface for the fputs C library function",
    -1,
    FputsMethods
};
```

Эти функции включают метаинформацию о вашем модуле, которая будет использоваться интерпретатором Python. Давайте рассмотрим каждую из вышеперечисленных структур, чтобы увидеть, как они работают.

#### PyMethodDef

Чтобы вызвать методы, определенные в вашем модуле, вам нужно сначала сообщить о них интерпретатору Python. Для этого вы можете использовать `PyMethodDef`. Это структура с 4 членами, представляющими один метод в вашем модуле.

В идеале в вашем модуле расширения Python C должно быть несколько методов, которые вы хотите вызывать из интерпретатора Python. Вот почему вам нужно определить массив структур `PyMethodDef`:

```C
static PyMethodDef FputsMethods[] = {
    {"fputs", method_fputs, METH_VARARGS, "Python interface for fputs C library function"},
    {NULL, NULL, 0, NULL}
};
```

Каждый отдельный член структуры содержит следующую информацию:

- `"fputs"` - это имя, которое пользователь напишет для вызова этой конкретной функции.

- `method_fputs` - это имя функции C для вызова.

- `METH_VARARGS` - это флаг, который сообщает интерпретатору, что функция будет принимать два аргумента типа `PyObject *`:

1. `self` - это объект модуля.
2. `args` - это кортеж, содержащий фактические аргументы вашей функции. Как объяснялось ранее, эти аргументы распаковываются с использованием `PyArg_ParseTuple()`.

- Последняя строка представляет собой значение, представляющее метод `docstring`.

#### PyModuleDef

Так же, как `PyMethodDef` содержит информацию о методах в вашем модуле расширения Python C, структура `PyModuleDef` содержит информацию о самом модуле. Это не массив структур, а единственная структура, которая используется для определения модуля:

```C
static struct PyModuleDef fputsmodule = {
    PyModuleDef_HEAD_INIT,
    "fputs",
    "Python interface for the fputs C library function",
    -1,
    FputsMethods
};
```

Всего в этой структуре 9 членов, но не все они обязательны. В приведенном выше блоке кода вы инициализируете следующие пять:

1. `PyModuleDef_HEAD_INIT` является членом типа `PyModuleDef_Base`, который рекомендуется иметь только это одно значение.

2. `"fputs"` - это название вашего модуля расширения Python C.

3. Строка - это значение, представляющее строку документации вашего модуля. Вы можете использовать NULL, чтобы не иметь строки документации, или вы можете указать строку документации, передав `const char *`, как показано во фрагменте выше. Он имеет тип `Py_ssize_t`. Вы также можете использовать `PyDoc_STRVAR()`, чтобы определить строку документации для вашего модуля.

4. `-1` - объем памяти, необходимый для хранения состояния вашей программы. Это полезно, когда ваш модуль используется в нескольких суб-интерпретаторах, и может иметь следующие значения:

-- Отрицательное значение указывает, что этот модуль не поддерживает суб-переводчиков.
-- Неотрицательное значение позволяет повторно инициализировать ваш модуль. Он также определяет требования к памяти вашего модуля, которые должны быть выделены на каждом сеансе суб-интерпретатора.

5. `FputsMethods` - это ссылка на таблицу методов. Это массив структур `PyMethodDef`, которые вы определили ранее.

Для получения дополнительной информации ознакомьтесь с официальной документацией Python по `PyModuleDef` ([документация](https://docs.python.org/3/c-api/module.html#c.PyModuleDef)).

#### PyMODINIT_FUNC

Теперь, когда вы определили свой модуль расширения Python C и структуры методов, пришло время использовать их. Когда программа Python импортирует ваш модуль в первый раз, она вызовет `PyInit_fputs()`:

```C
PyMODINIT_FUNC PyInit_fputs(void) {
    return PyModule_Create(&fputsmodule);
}
```

PyMODINIT_FUNC неявно делает 3 вещи, если указано как возвращаемый функцией тип:

1. Он неявно устанавливает тип возвращаемого значения функции как `PyObject *`.
2. Он объявляет любые специальные связи.
3. Он объявляет функцию как `extern «C.»` В случае, если вы используете C++, он говорит компилятору C++ не выполнять манипулирование именами на символах.

`PyModule_Create()` вернет новый объект модуля типа `PyObject *`. В качестве аргумента вы передадите адрес структуры метода, который вы уже определили ранее, `fputsmodule`.

**Примечание**. В Python 3 ваша функция инициализации должна возвращать тип `PyObject *`. Однако, если вы используете Python 2, `PyMODINIT_FUNC` объявляет тип возвращаемого значения функции как `void`.

### Собираем все вместе

Теперь, когда вы написали необходимые части вашего модуля расширения Python C, давайте сделаем шаг назад, чтобы увидеть, как все это сочетается. На следующей диаграмме показаны компоненты вашего модуля и их взаимодействие с интерпретатором Python:



















[Менеджер памяти](https://habr.com/en/company/ruvds/blog/441568/)

[Pandas](https://habr.com/en/company/ruvds/blog/442516/)

[Реализация словаря](https://habr.com/en/post/432996/)

[Реализация целого типа в CPython](https://habr.com/ru/post/455114/)

[Реализация строкового типа в CPython](https://habr.com/ru/post/480324/)


https://github.com/foobar167/junkyard/tree/master/co-occurrence_matrix/C_extension_for_Pythonhttps://github.com/foobar167/junkyard/tree/master/co-occurrence_matrix/C_extension_for_Python

[Прототип лабораторной работы](https://docs.google.com/document/d/1lXbsgWJUiGKM8jn_npiei0vVjDZwJsC7xcgp6W7Q_ss/edit)